<h3>6.1 模块加载机制</h3>

<b>6.1.1 模块的类型</b>

Node.js 的模块可以分为两大类，一类是核心模块，另一类是文件模块。核心模块就是Node.js 标准 API 中提供的模块，如 fs、http、net、vm 等，这些都是由 Node.js 官方提供的模块，编译成了二进制代码。我们可以直接通过 require 获取核心模块，例如 require('fs')。核心模块拥有最高的加载优先级，换言之如果有模块与其命名冲突，Node.js 总是会加载核心模块。

文件模块则是存储为单独的文件（或文件夹）的模块，可能是 JavaScript 代码、JSON 或编译好的 C/C++ 代码。文件模块的加载方法相对复杂，但十分灵活，尤其是和 npm 结合使用时。在不显式指定文件模块扩展名的时候，Node.js 会分别试图加上 .js、.json 和 .node扩展名。.js 是 JavaScript 代码，.json 是 JSON 格式的文本，.node 是编译好的 C/C++ 代码。

<b>6.1.2 按路径加载模块</b>

文件模块的加载有两种方式，一种是按路径加载，一种是查找 node_modules 文件夹。如果 require 参数以“ / ”开头，那么就以绝对路径的方式查找模块名称，例如 require ('/home/byvoid/module') 将会按照优先级依次尝试加载 /home/byvoid/module.js、/home/byvoid/module.json 和 /home/byvoid/module.node。
如果 require 参数以“ ./ ”或“ ../ ”开头，那么则以相对路径的方式来查找模块，这种方式在应用中是最常见的。例如前面的例子中我们用了require('./hello')来加载同一文件夹下的hello.js。

<b>6.1.3 通过查找 node_modules 目录加载模块</b>

如果require参数不以“ / ”、“ ./ ”或“ ../ ”开头，而该模块又不是核心模块，那么就要通过查找 node_modules 加载模块了。

<b>6.1.4 加载缓存</b>

Node.js 模块不会被重复加载，这是因为 Node.js 通过文件名缓存所有加载过的文件模块，所以以后再访问到时就不会重新加载了。

<b>6.1.5 加载顺序</b>

(1) 如果some_module 是一个核心模块，直接加载，结束。
(2) 如果some_module以“ / ”、“ ./ ”或“ ../ ”开头，按路径加载 some_module，结束。
(3) 假设当前目录为 current_dir，按路径加载 current_dir/node_modules/some_module。
	·如果加载成功，结束。
	·如果加载失败，令current_dir为其父目录。
	·重复这一过程，直到遇到根目录，抛出异常，结束。

<h3>6.2 控制流</h3>

<b>6.2.1 循环的陷阱</b>

<b>6.2.2 解决控制流难题</b>

<h3>6.3 Node.js 应用部署</h3>

<b>6.3.1 日志功能</b>

<b>6.3.2 使用cluster模块</b>

cluster的功能是生成与当前进程相同的子进程，并且允许父进程和子进程之间共享端口。

<b>6.3.3 启动脚本</b>

<b>6.3.4 共享80 端口</b>

虚拟主机，就是让多个网站共享使用同一服务器同一IP地址，通过域名的不同来划分请求。主流的HTTP服务器都提供了虚拟主机支持，如Nginx、Apache、IIS等。我们以Nginx为例，介绍如何通过反向代理实现Node.js 虚拟主机。 在Nginx 中设置反向代理和虚拟主机非常简单，下面是配置文件的一个示例：

```javascript
	server {
		listen 80;
		server_name mysite.com;
		location / {
			proxy_pass http://localhost:3000;
		}
	}
```

<h3>6.4 Node.js 不是银弹</h3>

在西方古老的传说里，有一种叫做“狼人”的可怕生物。这种生物平时和人类没有什么不同之处，但每到月圆之夜，他们就会变成狼身。当他们变成狼以后，兽性会不能控制，开始袭击普通的人类。狼人给人类带来了巨大的恐惧，因为他们是无法被一般的手段杀死的，只有用赐福过的银弹（Silver Bullet）才能杀死狼人。“银弹”因此成为了“任何能够带来极大效果的直接解决方案”的代名词。

Node.js 不适合做什么

1. 计算密集型的程序

2. 单用户多任务型应用

3. 逻辑十分复杂的事务

4. Unicode 与国际化