<h3>3.1 开始用 Node.js 编程</h3>

hello world ...


<b>3.1.3 建立 HTTP 服务器</b>

<b>小技巧——使用 supervisor</b>

如果你有 PHP 开发经验，会习惯在修改 PHP 脚本后直接刷新浏览器以观察结果，而你在开发 Node.js 实现的 HTTP 应用时会发现，无论你修改了代码的哪一部份，都必须终止Node.js 再重新运行才会奏效。这是因为 Node.js 只有在第一次引用到某部份时才会去解析脚本文件，以后都会直接访问内存，避免重复载入，而 PHP 则总是重新读取并解析脚本（如果没有专门的优化配置）。Node.js的这种设计虽然有利于提高性能，却不利于开发调试，因为我们在开发过程中总是希望修改后立即看到效果，而不是每次都要终止进程并重启。

supervisor 可以帮助你实现这个功能，它会监视你对代码的改动，并自动重启 Node.js。使用方法很简单，首先使用 npm 安装 supervisor：

>$ npm install -g supervisor

如果你使用的是 Linux 或 Mac，直接键入上面的命令很可能会有权限错误。原因是 npm需要把 supervisor 安装到系统目录，需要管理员授权，可以使用 sudo npm install -g supervisor 命令来安装。

接下来，使用 supervisor 命令启动 app.js：

>$ supervisor app.js

当代码被改动时，运行的脚本会被终止，然后重新启动。在终端中显示的结果如下：

supervisor 这个小工具可以解决开发中的调试问题。


<h3>3.2 异步式 I/O 与事件式编程</h3>

Node.js 最大的特点就是异步式 I/O（或者非阻塞 I/O）与事件紧密结合的编程模式。这种模式与传统的同步式 I/O 线性的编程思路有很大的不同，因为控制流很大程度上要靠事件和回调函数来组织，一个逻辑要拆分为若干个单元。

<b>3.2.1 阻塞与线程</b>

<b>同步式 I/O 和异步式 I/O 的特点</b>

<table>
    <thead>
    <tr>
        <td>同步式 I/O（阻塞式）</td>
        <td>异步式 I/O（非阻塞式）</td>
    </tr>
    </thead>
    <tbody>
    <tr>
    	<td>利用多线程提供吞吐量</td>
    	<td>单线程即可实现高吞吐量</td>
	</tr>
	<tr>
		<td>通过事件片分割和线程调度利用多核CPU</td>
		<td>通过功能划分利用多核CPU</td>
	</tr>
	<tr>
		<td>需要由操作系统调度多线程使用多核 CPU</td>
		<td>可以将单进程绑定到单核 CPU</td>
	</tr>
	<tr>
		<td>难以充分利用 CPU 资源</td>
		<td>可以充分利用 CPU 资源</td>
	</tr>
	<tr>
		<td>内存轨迹大，数据局部性弱</td>
		<td>内存轨迹小，数据局部性强</td>
	</tr>
	<tr>
		<td>符合线性的编程思维</td>
		<td>不符合传统编程思维</td>
	</tr>
	</tbody>
</table>

<b>3.2.2 回调函数</b>

Node.js 中，并不是所有的 API 都提供了同步和异步版本。Node.js 不鼓励使用同步 I/O。

<b>3.2.3 事件</b>

Node.js 所有的异步 I/O 操作在完成时都会发送一个事件到事件队列。在开发者看来，事件由 EventEmitter 对象提供。

Node.js 的事件循环机制：Node.js 程序由事件循环开始，到事件循环结束，所有的逻辑都是事件的回调函数，所以 Node.js 始终在事件循环中，程序入口就是事件循环第一个事件的回调函数。

事件的回调函数在执行的过程中，可能会发出 I/O 请求或直接发射（emit）事件，执行完毕后再返回事件循环，事件循环会检查事件队列中有没有未处理的事件，直到程序结束。



